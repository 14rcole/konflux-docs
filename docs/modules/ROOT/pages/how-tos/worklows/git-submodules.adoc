= Git Submodule guideline

This document outlines some basic guidelines for synchronizing changes between an upstream and downstream repository using Git submodules.

By leveraging Git submodules, it is possible to maintain a consistent and up-to-date relationship between related repositories (upstream and downstream) while having more control of how the project is built, tested and released.

Additionally, the integration with Konflux can automate key aspects of this process, ensuring that changes from the upstream repository are efficiently and reliably propagated to the downstream repository.

== Implementing this guideline
=== Basic definitions

- **Upstream repo**: a community project which you do not have push access to (or which you do not want to push CI changes into).

- **Downstream repo**: a self-owned copy of the upstream repository whose build, test, release lifecycle you want to control completely.

=== Create a downstream repo

The downstream repo can be used to do the following:

* hold the git submodule reference to the upstream repository.
* use the contents of the git submodule in a Containerfile for further edits.
* onboarded onto {ProductName}.

==== Configuring components

CAUTION: Make sure to properly set the xref:/how-tos/creating.doc#context-and-containerfile-path[Context and Containerfile path] as required for the artifact builds.

See xref:/how-tos/creating.adoc[Creating applications and components] for more details.

==== Configuring the Containerfile

In the Containerfile you can specify the git submodule directories and add any necessary edits that differ from the upstream repository. Here is a basic example:

[source, Dockerfile]
----
FROM <base-image>

# Install necessary dependencies
RUN dnf -y install <dependencies>

# Set the working directory
ENV <SUBMODULEPKG> /path/to/submodule
WORKDIR ${<SUBMODULEPKG>}

# Commands to update the submodule for the current image build
RUN sed -i 's/<old-text>/<new-text>/g' file/in/submodule/directory
# Commands to build binary from submodule sources
RUN go build file/in/submodule/directory

WORKDIR /app

LABEL name="<name" \
      summary="<summary>" \
      description="<description>"

ENTRYPOINT ["<entrypoint-executable>"]
----

=== Create the git submodule for the upstream repo to track it

After creating the downstream repo, add a git submodule for the upstream repo:

[source, bash]
----
git submodule add <upstream-url>
----

Check and configure the git submodule config:
[source, gitmodules]
----
# .gitmodules
[submodule "<project-name>"]
  path = <path-in-downstream-repo>
  url = https://github.com/<namespace>/<project>.git
----
See the link:https://git-scm.com/docs/gitsubmodules[Git documentation] for more details on configuring git submodules.

**Note**: By default the branch is not specified in the git submodule configuration file when adding a git submodule.
see link:https://git-scm.com/docs/gitsubmodules[Git documentation] for more details on how to configure the branches for the submodules.

=== Onboard the component onto {ProductName}

After creating the downstream repository you can onboard the component. See xref:/how-tos/creating.adoc[Creating applications and components] for more details.

=== Using private repositories as a git submodule:

When using private repositories we encourage that you give the link:https://github.com/apps/red-hat-konflux[Red Hat {ProductName} Github app] access to that private repository.

== Benefits of this guideline

1. **Separation of Concerns**: The downstream repo can stay focused on its specific development goals while the submodule handles its own code. This keeps your downstream repo clean and modular.
2. **Automatic Dependency Syncing with link:https://github.com/renovatebot/renovate[Renovate]**: By automating the dependency sync process, whether its syncing the git submodule, the Containerfile, etc. your downstream repo can always use the latest code from the upstream repo(s), ensuring that your project benefits from new features, bug fixes, and security updates.
3. **Version Control for upstream repos**: You can lock the submodule to a specific commit or version, giving you control over when and how updates are integrated. This is especially useful if an upstream update introduces breaking changes.
4. **{ProductName} CI**: Automated building and testing of your software artifacts help ensure that changes in the upstream repo don't break your downstream project.

== Potential drawbacks

1. **Complexity**: Managing submodules and automating their updates adds complexity to your workflow, such as:
  - Debugging issues related to submodule updates
  - Your automation configuration can be more challenging.
  - Updates in the submodules can be opaque which can result in drift between your build process and that of the original repository.