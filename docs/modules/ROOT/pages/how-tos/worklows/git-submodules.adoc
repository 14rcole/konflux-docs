= Git Submodule guideline

This document outlines some basic guidelines for synchronizing changes between an upstream and downstream repository using Git submodules.

By leveraging Git submodules, it is possible to maintain a consistent and up-to-date relationship between related repositories (upstream and downstream) while having more control of how the project is built, tested and released.

Additionally, the integration with Konflux can automate key aspects of this process, ensuring that changes from the upstream repository are efficiently and reliably propagated to the downstream repository.

== Implementing this guideline
=== Basic definitions

- **Upstream repo**: a community project which you do not have push access to (or which you do not want to push CI changes into).

- **Downstream repo**: a self-owned copy of the upstream repository whose build, test, release lifecycle you want to control completely.

=== Create a downstream repo

The downstream repo can be used to do the following:

* hold the git submodule reference to the upstream repository.
* use the contents of the git submodule in a Containerfile for further edits.
* onboarded onto {ProductName}.

==== Configuring components

Here is an example of a component definition:

[source, yaml]
----
apiVersion: appstudio.redhat.com/v1alpha1
kind: Component
metadata:
  name: <component-name>
  namespace: <project-namespace>
  annotations:
    build.appstudio.openshift.io/request: configure-pac
    image.redhat.com/generate: '{"visibility": "public"}'
spec:
  application: <application-name>
  componentName: <component-name>
  source:
    git:
      revision: main
      url: <downstream repo name>
      dockerfileUrl: <Dockerfile/Containefile path in downstream repository>
      context: <directory path used to build the Containerfile/Dockerfile>
----

See xref:/how-tos/creating.adoc[Creating applications and components] for more details.

==== Configuring the Containerfile

In the Containerfile you can specify the git submodule directories and add any necessary edits that differ from the upstream repository. Here is a basic example:

[source, Dockerfile]
----
FROM <base-image>
ENV <SUBMODULEPKG> /path/to/submodule

# Install necessary dependencies
RUN dnf -y install <dependencies>

# Set the working directory
WORKDIR ${<SUBMODULEPKG>}

RUN sed -i 's/<old-text>/<new-text>/g' /file/in/submodule/directory

WORKDIR /app

ENTRYPOINT ["<entrypoint-executable>"]
----

=== Create the git submodule for the upstream repo to track it

After creating the downstream repo, add a git submodule for the upstream repo:

[source, bash]
----
git submodule add <upstream-url>
----

Check and configure the git submodule config:
[source, gitmodules]
----
# .gitmodules
[submodule "<project-name>"]
  path = <path-in-downstream-repo>
  url = https://github.com/<namespace>/<project>.git
----
See the link:https://git-scm.com/docs/gitsubmodules[Git documentation] for more details on configuring git submodules.

**Note**: By default the branch is not specified in the git submodule configuration file when adding a git submodule.
see link:https://git-scm.com/docs/gitsubmodules[Git documentation] for more details on how to configure the branches for the submodules.

=== Onboard the component onto {ProductName}

After creating the downstream repository you can onboard the component. See xref:/how-tos/creating.adoc[Creating applications and components] for more details.

=== Using private repositories as a git submodule

==== Github

When using private repositories we encourage that you give the link:https://github.com/apps/red-hat-konflux[Red Hat {ProductName} Github app] access to that private repository.

==== Gitlab

For Gitlab repositories please see <<create-source-control-secrets,Creating source control secrets>>

== Benefits of this guideline

1. **Separation of Concerns**: The downstream repo can stay focused on its specific development goals while the submodule handles its own code. This keeps your downstream repo clean and modular.
2. **Automatic Dependency Syncing with link:https://github.com/renovatebot/renovate[Renovate]**: By automating the dependency sync process, whether its syncing the git submodule, the Containerfile, etc. your downstream repo can always use the latest code from the upstream repo(s), ensuring that your project benefits from new features, bug fixes, and security updates.
3. **Version Control for upstream repos**: You can lock the submodule to a specific commit or version, giving you control over when and how updates are integrated. This is especially useful if an upstream update introduces breaking changes.
4. **{ProductName} CI**: Automated building and testing of your software artifacts help ensure that changes in the upstream repo don't break your downstream project.

== Potential drawbacks

1. **Complexity**: Managing submodules and automating their updates adds complexity to your workflow, such as:
  - Debugging issues related to submodule updates
  - Your automation configuration can be more challenging.
2. **Dependency Management**: Breaking changes in the upstream repo can affect your downstream repo. In scenarios like this it is strongly recommended to proceed with caution when fixing such issues.
3. **Merge Conflicts**: If you have automatic updates configured, this might lead to merge conflicts, especially if both the upstream and downstream repos are being actively developed. Resolving these conflicts might require manual effort.

== Gitlab support

GitLab is supported, you need to follow xref:/how-tos/configuring/creating-secrets.adoc [Creating secrets for your build] to provide the token to access your GitLab repository.

To do that you have to create a secret from command line. Refer to link:https://gitlab.cee.redhat.com/konflux/docs/users/-/blob/main/topics/getting-started/getting-access.md#accessing-konflux-via-cli[Accessing {ProductName} via CLI] for how to login with CLI.

Also refer to this doc for which cluster you can use: link:https://gitlab.cee.redhat.com/konflux/docs/users/-/blob/main/topics/overview/deployments.md[deployments].

For example, you can't access internal network with public clusters, with internal clusters, you can only use internal gitlab repositories plus gitlab.com/redhat repositories, there are other restrictions as well.

After onboarding your downstream project repo in Gitlab onto {ProductName} you should be able to follow a similar guideline to the one outlined here.